# 從 PRD 生成任務清單

## 目標

引導 AI 助手根據現有的產品需求文件（PRD）創建詳細的、逐步的 Markdown 格式任務清單。該任務清單應指導開發人員完成實作。

## 輸出

### 主要任務清單

- **格式：** Markdown (`.md`)
- **位置：** `/docs/specs/[prd-slug-name]`
- **檔案名稱：** `implementation.md`

### 驗收條件檔案

- **格式：** Gherkin (`.feature`)
- **位置：** `/docs/specs/[prd-slug-name]`
- **檔案名稱：** `acceptance.feature`

## 流程

1.  **接收 PRD 參考：** 用戶指向特定的 PRD 檔案
2.  **分析 PRD：** AI 讀取並分析指定 PRD 的功能需求、用戶故事和其他部分。如果 PRD 中引用了研究文件，也一併讀取相關研究以獲得更深入的背景資訊。
3.  **評估現狀：** 檢視現有程式碼庫，了解現有的基礎設施、架構模式和慣例。同時，識別任何已存在且可能與 PRD 需求相關的元件或功能。然後，識別可以利用或需要修改的現有相關檔案、元件和工具。
4.  **生成任務與任務說明：** 基於 PRD 分析和現狀評估，創建檔案並生成實作功能所需的主要任務。根據判斷決定使用多少個任務，通常約為 5-7 個。為每個任務生成詳細的任務說明（以條列式呈現），用於與開發者溝通開發範圍和實作細節，確保涵蓋 PRD 暗示的所有實作要點。**若使用者在對話中提及「TDD」，則參考「TDD 實作流程指導」章節，將每個主要任務轉換為測試驅動開發的標準流程。**
5.  **生成驗收條件：** 基於 PRD 中的 Acceptance Criteria 部分，創建 Gherkin 格式的驗收測試場景。每個驗收條件應轉換為具體的 Feature、Scenario 和 Given/When/Then 步驟。這些步驟將由 AI 通過指令或 MCP 瀏覽器操作直接執行，而非傳統的 Cucumber glue code。
6.  **識別相關檔案：** 根據任務和 PRD，識別需要創建或修改的潛在檔案。在 `相關檔案` 部分列出這些檔案，包括對應的測試檔案（如適用）。
7.  **生成最終輸出：** 將任務、任務說明、相關檔案和備註結合到最終的 Markdown 結構中。在任務清單末尾添加驗收測試任務。
8.  **儲存檔案：**
    - 將任務清單儲存為 `implementation.md`
    - 將 Gherkin 驗收條件儲存為 `acceptance.feature`

## 輸出格式

### 任務清單 (implementation.md)

生成的任務清單**必須**遵循以下結構：

```markdown
# 實作計畫

## PRD 參考

**PRD 文件路徑：** `[PRD 檔案的相對路徑]`
**相關研究文件：** `[如果 PRD 引用了研究文件，列出研究文件路徑]`

> **重要提醒：** 實作過程中請經常參考 PRD 文件以了解：
>
> - 功能的商業目標和用戶價值
> - 完整的用戶故事和使用場景
> - 非功能性需求（性能、安全性等）
> - 系統架構和技術決策的背景脈絡
> - 研究文件中的深入分析和建議（如適用）

## 相關檔案

- `path/to/potential/file1.ts` - 簡要說明此檔案為何相關（例如：包含此功能的主要元件）。
- `path/to/another/file.tsx` - 簡要說明（例如：資料提交的 API 路由處理器）。
- `lib/utils/helpers.ts` - 簡要說明（例如：計算所需的工具函數）。
- `acceptance.feature` - Gherkin 格式的驗收測試場景

## 任務

- [ ] 1. 任務標題
  - 1.1 實作要點描述
  - 1.2 實作要點描述
  - 1.3 實作要點描述

- [ ] 2. 任務標題
  - 2.1 實作要點描述
  - 2.2 實作要點描述

- [ ] 3. 任務標題
  - 3.1 實作要點描述

- [ ] 4. 執行驗收測試
  - 4.1 使用 AI 讀取 acceptance.feature 檔案
  - 4.2 透過指令或 MCP 瀏覽器操作執行每個場景
  - 4.3 驗證所有場景通過並記錄結果
```

### 驗收條件檔案 (acceptance.feature)

Gherkin 格式的驗收條件**必須**遵循以下結構：

```gherkin
# language: zh-TW
功能: [功能名稱]
  作為 [使用者角色]
  我想要 [功能目標]
  以便 [商業價值]

  背景:
    假設 [系統初始狀態]
    並且 [額外的前置條件]

  場景: [場景名稱 - 對應 PRD 中的一個驗收條件]
    假設 [前置條件]
    當 [使用者執行的動作]
    那麼 [預期結果]
    並且 [額外的驗證]

  場景: [另一個場景名稱]
    假設 [前置條件]
    當 [使用者執行的動作]
    那麼 [預期結果]

  場景大綱: [參數化的場景]
    假設 用戶輸入 "<input>"
    當 系統處理輸入
    那麼 應該返回 "<output>"

    例子:
      | input | output |
      | 值1   | 結果1  |
      | 值2   | 結果2  |
```

### 驗收測試執行說明

驗收測試將由 AI 直接執行，而非使用傳統的 Cucumber step definitions：

1. **AI 讀取場景**：AI 解析 `acceptance.feature` 中的每個場景
2. **轉換為操作**：將 Given/When/Then 步驟轉換為：
   - 終端指令（用於 API 測試、檔案操作等）
   - MCP 瀏覽器操作（用於 UI 測試）
   - 資料驗證檢查
3. **執行與驗證**：依序執行每個步驟並驗證結果
4. **報告結果**：列出每個場景的執行結果，如果執行有預期之外的情況或是警告時請額外說明狀況

## 任務格式說明

- 每個任務使用核取方塊 `[ ]` 標記
- 任務編號採用簡單數字（1, 2, 3...）
- 任務說明以條列式呈現，編號格式為 X.Y（如 1.1, 1.2）
- 任務說明應涵蓋該任務的所有實作要點和開發範圍

## 目標受眾

假設任務清單的主要讀者是**初級開發人員**，他們將在了解現有程式碼庫背景的情況下實作功能。

## TDD 實作流程指導

當使用者在對話中提及「TDD」時，系統應將每個主要任務轉換為測試驅動開發（Test-Driven Development）的標準流程。此章節詳細說明 TDD 任務的轉換邏輯和執行原則。

### TDD 流程概述

TDD 遵循「紅燈-綠燈-重構」的循環，確保每個功能都有對應的測試，並且測試先於實作撰寫。每個主要任務都會被轉換為包含完整 TDD 循環的 8 個步驟。

### 任務轉換規則

#### 原始任務結構
```markdown
- [ ] 1. 任務標題
  - 1.1 實作要點描述
  - 1.2 實作要點描述
  - 1.3 實作要點描述
```

#### TDD 模式下的轉換結果
```markdown
- [ ] 1. 任務標題
  - [ ] 1.1 撰寫空的類別、函式並拋出未實作錯誤
  - [ ] 1.2 撰寫測試敘述
  - [ ] 1.3 實作測試邏輯
  - [ ] 1.4 執行測試，確保測試失敗
  - [ ] 1.5 實作要點描述（原本任務）
  - [ ] 1.6 實作要點描述（原本任務）
  - [ ] 1.7 實作要點描述（原本任務）
  - [ ] 1.8 執行測試，確保測試成功
```

### TDD 步驟詳細說明

#### 步驟 1.1：撰寫空的類別、函式並拋出未實作錯誤
- **目的：** 建立基本的程式碼結構，讓測試能夠通過型別檢查
- **重要原則：** 此階段不實作任何邏輯，只建立介面
- **錯誤格式：** 使用 `throw new Error('Not implemented')` 
- **範例：**
  ```javascript
  class UserService {
    registerUser(userData) {
      throw new Error('Not implemented');
    }
  }
  ```

#### 步驟 1.2：撰寫測試敘述
- **目的：** 定義測試範圍，讓開發者確認測試的合理性
- **格式：** 使用 describe/it 結構
- **測試範圍原則：** 專注在主流程和主要錯誤情境，不要鉅細靡遺地測試各種邊緣案例。邊緣案例應在發現問題後再逐漸加入
- **開發者確認：** **此步驟完成後必須暫停，等待開發者確認測試範圍**
- **範例（專注主流程）：**
  ```javascript
  describe('UserService', () => {
    it('should register a new user with valid data', () => {
      // TBD - 主要成功流程
    });
    
    it('should throw error when email already exists', () => {
      // TBD - 主要錯誤情境
    });
    
    // 注意：避免一開始就寫太多邊緣案例
    // 如 invalid email format, empty password 等
    // 這些可在後續發現問題時再加入
  });
  ```

#### 步驟 1.3：實作測試邏輯
- **目的：** 實作具體的測試邏輯
- **執行時機：** 在開發者確認測試範圍後進行
- **範例：**
  ```javascript
  describe('UserService', () => {
    it('should register a new user with valid data', () => {
      const userService = new UserService();
      const userData = { email: 'test@example.com', password: '123456' };
      
      const result = userService.registerUser(userData);
      
      expect(result).toBeDefined();
      expect(result.id).toBeDefined();
    });
  });
  ```

#### 步驟 1.4：執行測試，確保測試失敗（紅燈階段）
- **目的：** 驗證測試邏輯正確，確保在未實作時測試會失敗
- **預期結果：** 所有新增的測試都應該失敗
- **執行方式：** 使用專案的測試命令（如 `npm test`、`yarn test`）

#### 步驟 1.5-1.7：原始實作要點
- **目的：** 實作原本任務中定義的功能邏輯
- **原則：** 保持原有的實作要點內容，按照原始順序執行
- **實作目標：** 讓步驟 1.4 中失敗的測試能夠通過

#### 步驟 1.8：執行測試，確保測試成功（綠燈階段）
- **目的：** 驗證實作正確，確保所有測試都通過
- **預期結果：** 原本失敗的測試現在應該全部通過
- **執行方式：** 使用專案的測試命令

### 開發者確認機制

#### 確認時機
在步驟 1.2「撰寫測試敘述」完成後，系統**必須明確暫停**並要求開發者確認。

#### 確認內容
- **測試範圍：** 確認測試是否涵蓋了主要功能面向（成功流程 + 主要錯誤）
- **測試複雜度：** 確認測試數量是否適中，避免認知過載
- **邊緣案例控制：** 確認是否避免了過多邊緣案例，專注在核心流程

#### 確認格式
```
⚠️  **開發者確認需求**

已完成測試敘述的撰寫，請審核以下測試範圍：

[列出所有 describe/it 結構]

請確認：
1. 測試範圍是否專注在主流程和主要錯誤？
2. 是否避免了過多邊緣案例？
3. 測試複雜度是否適中？

**請回覆「確認」或提供調整建議後，我將繼續實作測試邏輯。**
```

### 測試框架標準

#### 語法風格
- 使用 `describe/it` 結構
- 支援 Jest、Mocha 等主流測試框架

#### 錯誤處理
- 未實作錯誤：`throw new Error('Not implemented')`
- 保持錯誤訊息的一致性

### 與驗收測試的關係

TDD 流程與現有的 Gherkin 格式驗收測試是**互補關係**：

- **驗收測試（Gherkin）：** 驗證整體功能和使用者故事
- **TDD 測試：** 驗證個別元件和函式的正確性

兩種測試都會保留在最終的實作計畫中。

### TDD 模式下的 implementation.md 範例

以下是啟用 TDD 模式時，任務清單的完整範例：

```markdown
# 實作計畫

## PRD 參考

**PRD 文件路徑：** `docs/specs/2025-08-29-user-management/prd.md`

> **重要提醒：** 實作過程中請經常參考 PRD 文件以了解：
>
> - 功能的商業目標和用戶價值
> - 完整的用戶故事和使用場景
> - 非功能性需求（性能、安全性等）
> - 系統架構和技術決策的背景脈絡

## 相關檔案

- `src/services/UserService.js` - 用戶註冊和管理的主要服務類別
- `src/services/UserService.test.js` - UserService 的單元測試檔案
- `src/models/User.js` - 用戶數據模型
- `src/models/User.test.js` - User 模型的測試檔案
- `acceptance.feature` - Gherkin 格式的驗收測試場景

## TDD 步驟執行指導

### 步驟 1.1：撰寫空的類別、函式並拋出未實作錯誤
- **目的：** 建立基本的程式碼結構，讓測試能夠通過型別檢查
- **重要原則：** 此階段不實作任何邏輯，只建立介面
- **錯誤格式：** 使用 `throw new Error('Not implemented')` 

### 步驟 1.2：撰寫測試敘述
- **目的：** 定義測試範圍，讓開發者確認測試的合理性
- **格式：** 使用 describe/it 結構
- **測試範圍原則：** 專注在主流程和主要錯誤情境，不要鉅細靡遺地測試各種邊緣案例。邊緣案例應在發現問題後再逐漸加入
- **開發者確認：** **此步驟完成後必須暫停，等待開發者確認測試範圍**

### 步驟 1.3：實作測試邏輯
- **目的：** 實作具體的測試邏輯
- **執行時機：** 在開發者確認測試範圍後進行

### 步驟 1.4：執行測試，確保測試失敗（紅燈階段）
- **目的：** 驗證測試邏輯正確，確保在未實作時測試會失敗
- **預期結果：** 所有新增的測試都應該失敗
- **執行方式：** 使用專案的測試命令（如 `npm test`、`yarn test`）

### 步驟 1.5-1.7：原始實作要點
- **目的：** 實作原本任務中定義的功能邏輯
- **原則：** 保持原有的實作要點內容，按照原始順序執行
- **實作目標：** 讓步驟 1.4 中失敗的測試能夠通過

### 步驟 1.8：執行測試，確保測試成功（綠燈階段）
- **目的：** 驗證實作正確，確保所有測試都通過
- **預期結果：** 原本失敗的測試現在應該全部通過
- **執行方式：** 使用專案的測試命令

## 任務

- [ ] 1. 實作用戶註冊功能
  - [ ] 1.1 撰寫空的類別、函式並拋出未實作錯誤
  - [ ] 1.2 撰寫測試敘述
  - [ ] 1.3 實作測試邏輯
  - [ ] 1.4 執行測試，確保測試失敗
  - [ ] 1.5 建立用戶數據驗證邏輯
  - [ ] 1.6 實作密碼加密和安全處理
  - [ ] 1.7 整合數據庫操作和錯誤處理
  - [ ] 1.8 執行測試，確保測試成功

- [ ] 2. 實作用戶登入驗證
  - [ ] 2.1 撰寫空的類別、函式並拋出未實作錯誤
  - [ ] 2.2 撰寫測試敘述
  - [ ] 2.3 實作測試邏輯
  - [ ] 2.4 執行測試，確保測試失敗
  - [ ] 2.5 實作登入憑證驗證邏輯
  - [ ] 2.6 建立 JWT token 生成機制
  - [ ] 2.7 執行測試，確保測試成功

- [ ] 3. 建立用戶權限管理
  - [ ] 3.1 撰寫空的類別、函式並拋出未實作錯誤
  - [ ] 3.2 撰寫測試敘述
  - [ ] 3.3 實作測試邏輯
  - [ ] 3.4 執行測試，確保測試失敗
  - [ ] 3.5 定義角色和權限結構
  - [ ] 3.6 實作權限檢查中介軟體
  - [ ] 3.7 執行測試，確保測試成功

- [ ] 4. 執行驗收測試
  - 4.1 使用 AI 讀取 acceptance.feature 檔案
  - 4.2 透過指令或 MCP 瀏覽器操作執行每個場景
  - 4.3 驗證所有場景通過並記錄結果
```

注意在 TDD 模式下的關鍵差異：

1. **子任務格式：** 每個子任務都有 `[ ]` 核取方塊，方便追蹤進度
2. **8 步驟結構：** 每個主要任務都遵循完整的 TDD 循環
3. **測試檔案：** 相關檔案中包含對應的 `.test.js` 檔案
4. **開發者確認：** 在步驟 1.2 完成後會暫停等待確認

# 任務清單管理

用於在 Claude Code 中管理任務清單的指導原則，以追蹤完成 PRD 的進度

## 工作流程脈絡

### 整體開發流程

本指令是 claude-code-config 三步驟開發流程中的**第三步：任務執行**。完整流程如下：

1. **【選用】需求研究 (`/research`)**：深入調查技術問題、探索解決方案、產出研究文件
2. **需求澄清 (`/create-prd`)**：透過問答釐清需求、產出 PRD 文件
3. **實作規劃 (`/create-impl-plan`)**：分析 PRD 和程式碼庫、產出任務清單和驗收測試
4. **【當前】任務執行 (`/process-task-list`)**：逐一實作任務、執行驗收測試

### 當前階段的輸入與輸出

**輸入來源**：
- Implementation.md（任務清單和實作要點）
- PRD 文件（功能背景和商業需求）
- acceptance.feature（驗收測試場景）
- 【選用】Research 文件（如果 PRD 中有引用）

**輸出目標**：
- 實際的程式碼變更
- Git commits（每個任務完成後）
- 驗收測試結果

### 各參考文件的角色

**implementation.md**：
- 提供任務清單和優先級
- 提供實作要點和技術指導
- 提供「實作參考資訊」（來自 research 和 PRD 的技術細節）

**prd.md**：
- 提供功能的商業背景和使用者價值
- 幫助理解「為什麼」要這樣實作
- 提供高層次的技術方向

**acceptance.feature**：
- 提供驗收測試的具體場景
- 幫助理解功能的預期行為

**research 文件**（如果有）：
- 提供問題分析和技術選型的背景
- 提供已驗證的解決方案和最佳實踐
- 補充深入的技術脈絡

### 當前階段的職責範圍

**應該做的事**：
- 按順序執行任務清單中的任務
- 參考實作要點完成實作
- 在需要理解背景時參考 PRD 和 research
- 完成任務後進行 git commit
- 執行驗收測試

**不應該做的事**：
- 擅自修改任務清單的順序或範圍（除非發現明確的問題）
- 忽略實作參考資訊中的技術決策
- 在不理解商業背景的情況下實作

## Claude Code 任務清單同步

Claude Code 提供內建的 TodoWrite 工具來管理任務，這與 Cursor 等其他編輯器的工作方式不同。為了充分利用 Claude Code 的功能同時保持任務記錄的持久性，我們需要同步機制。對於 TDD 任務，採用簡化的單向同步策略。

### 同步機制

#### 一般任務同步
- **初始載入：** 從 `implementation.md` 的「任務概要」區塊讀取任務清單，使用 TodoWrite 工具將其轉換為 Claude Code 內部任務清單
- **雙向同步：** 當 Claude Code 內部任務清單狀態改變時（pending、in_progress、completed），必須同步更新 `implementation.md` 中「任務概要」區塊對應的任務項目
- **格式對應：**
  - Claude Code `pending` → Markdown `[ ]`
  - Claude Code `in_progress` → Markdown `[ ]` (可在旁邊加註 _進行中_)
  - Claude Code `completed` → Markdown `[x]`
- **任務識別：** 使用任務標題（而非編號）作為唯一識別方式，確保概要和細節區塊的標題完全一致

#### TDD 任務簡化同步
- **單向讀取：** 從 `implementation.md` 的「任務概要」讀取 TDD 任務（標題包含「使用 TDD 開發流程」），在 TodoWrite 中動態展開為 7 個子任務
- **子任務隔離：** TDD 子任務狀態僅在 TodoWrite 中管理，不同步回 `implementation.md`
- **母任務完成：** 只有當所有 7 個子任務標記為 `completed` 後，才將 `implementation.md` 中「任務概要」區塊的母任務標記為 `[x]`
- **狀態檢查：** 母任務完成狀態基於子任務完成數量，而非中間進度

### 為什麼需要同步

1. **持久化：** TodoWrite 的任務只存在於當前對話，implementation.md 提供永久記錄
2. **可見性：** 用戶可以直接在檔案中查看任務進度
3. **協作：** 其他開發者可以透過 implementation.md 了解專案狀態
4. **版本控制：** implementation.md 可以透過 Git 追蹤歷史變更

## 任務實作

- **一次一個任務：** 完成一個任務後，在請求用戶許可並獲得「yes」或「y」回應之前，**不要**開始下一個任務
- **執行時參考：**
  - 從「任務概要」區塊識別當前要執行的任務
  - 從「任務細節」區塊找到對應的任務章節（標題完全一致）
  - 參考該任務的「實作要點」和「相關檔案」進行實作

- **實作過程記錄**：
  - 在任務執行過程中，遇到以下情況時，**立即**在「實作備註」區塊記錄：

    1. **方向調整**：發現原計畫不可行或需要改用其他方法時
       - 觸發條件：使用者指出錯誤、發現技術限制、原方法行不通
       - 記錄格式：`[方向調整] 原計畫 X 因 Y 原因不可行，改用 Z 方法`
       - 範例：`[方向調整] 原計畫使用 localStorage 但需跨 tab 同步，改用 BroadcastChannel API`

    2. **技術障礙**：遇到預期外的問題需要特別處理時
       - 觸發條件：API 不支援、效能瓶頸、相容性問題、需要繞過的限制
       - 記錄格式：`[技術障礙] 遇到 X 問題，因為 Y，解決方式是 Z`
       - 範例：`[技術障礙] Next.js 動態路由不支援 SSG，需使用 generateStaticParams 預生成路徑`

    3. **關鍵決策**：與使用者討論超過 3 輪才確定的技術方案
       - 觸發條件：有多個可行方案、需要權衡取捨、影響後續任務
       - 記錄格式：`[技術決策] 在 X 和 Y 方案之間選擇 Z，因為 W`
       - 範例：`[技術決策] 在 REST 和 GraphQL 之間選擇 REST，因現有後端已是 REST 且團隊更熟悉`

    4. **後續依賴**：後續任務必須知道的資訊
       - 觸發條件：建立了新的前置條件、修改了共享資源、有執行順序要求
       - 記錄格式：`[後續依賴] 後續任務需注意 X，因為 Y`
       - 範例：`[後續依賴] 後續任務需注意必須先呼叫 initAuth() 才能使用其他 auth 函數`

  - **照預期完成時**：如果整個任務執行過程都按照任務敘述順利完成，沒有觸發上述任何情況，則標註「照預期開發」

- **完成協議：**
  1. 實作任務時，參考「任務細節」中的所有實作要點
  2. 完成任務後，請按照以下順序操作：
  - **檢查並完善實作備註**：
    - 檢視「實作備註」區塊，確認已記錄所有方向調整、技術障礙、關鍵決策、後續依賴
    - 如果執行過程中已經即時記錄，確認記錄完整清晰
    - 如果執行過程中沒有觸發任何需要記錄的情況，標註「照預期開發」
    - **不要**重複記錄任務敘述中已有的實作細節
  - **更新任務狀態**：在 `implementation.md` 的「任務概要」區塊中將完成的任務標記為 `[x]`
  - **暫存變更**：執行 `git add .`（包含 implementation.md 的變更）
  - **清理**：在提交前移除任何臨時檔案和臨時程式碼
  - **提交**：使用描述性的提交訊息，該訊息應：
    - 使用慣例提交格式（`feat:`、`fix:`、`refactor:` 等）
    - 總結任務中完成的內容
    - 列出關鍵變更和新增內容
    - 引用任務標題（而非編號）和 PRD 上下文
  3. 提交後，在 TodoWrite 中將任務狀態更新為 `completed`

- 每個任務完成後停止並等待用戶的許可。

## 任務清單維護

1. **工作時更新任務清單：**
   - 使用 TodoWrite 工具管理內部任務狀態
   - 同步更新 implementation.md「任務概要」區塊中的任務標記（`[ ]` → `[x]`）
   - 當新增任務時，必須同時更新：
     - 「任務概要」區塊：新增 `- [ ] 任務標題`
     - 「任務細節」區塊：新增完整的任務章節（### 任務標題 + 實作要點 + 相關檔案 + 實作備註）
     - TodoWrite 內部清單

2. **維護任務細節區塊：**
   - 每個任務的「相關檔案」列出該任務創建或修改的檔案
   - 為每個檔案提供一行描述其用途的說明
   - 任務執行後填寫「實作備註」，記錄重要的上下文資訊

## TDD 任務自動分解機制

當在 `implementation.md` 中發現標註「使用 TDD 開發流程」的任務時，Claude Code 必須實施以下自動分解機制，以提供更精細的 TDD 進度追蹤。

### 分解觸發條件

- **檢測標註**：任務標題包含「使用 TDD 開發流程」文字（支援空格變化，如「使用TDD開發流程」）
- **分解時機**：只有當 TDD 任務在 TodoWrite 中標記為 `in_progress` 時才進行分解
- **延遲展開**：未開始的 TDD 任務在 TodoWrite 中保持單一任務形式

### 自動分解規則

當 TDD 任務標記為 `in_progress` 時，自動分解為以下 7 個子任務：

1. **`[任務名稱] - 先跑測試`**
   - 執行現有測試，確保所有測試通過

2. **`[任務名稱] - 確認介面修改需求`**
   - 新程式邏輯：創建拋出「Not implemented」錯誤的空實現
   - 修改現有程式：分析介面修改需求，根據情況處理
     - 新增 function/method：創建空介面實作
     - 純邏輯修正（介面不變）：跳過空介面步驟，直接進行下一步
     - 介面參數變更：修改既有 function/method 簽名

3. **`[任務名稱] - 寫測試敘述`**
   - 撰寫 describe/it 區塊的測試描述

4. **`[任務名稱] - 實作測試邏輯`**
   - 撰寫實際的測試邏輯和斷言

5. **`[任務名稱] - 跑測試（紅燈階段）`**
   - 執行測試，確保測試失敗

6. **`[任務名稱] - 實作實際程式碼`**
   - 實現真實邏輯替換空實現

7. **`[任務名稱] - 再次跑測試（綠燈階段）`**
   - 執行測試，確保測試通過

### 子任務執行規範

- **順序執行**：子任務必須按照上述順序依次執行
- **狀態限制**：同時只能有一個子任務處於 `in_progress` 狀態
- **完成條件**：所有 7 個子任務標記為 `completed` 後，母任務才能標記為完成
- **同步範圍**：子任務狀態僅在 TodoWrite 中管理，不同步回 `implementation.md`

### 非 TDD 任務相容性

- **無標註任務**：沒有「使用 TDD 開發流程」標註的任務保持原有處理方式
- **混合清單**：TDD 和非 TDD 任務可以共存於同一個任務清單中
- **狀態獨立**：非 TDD 任務的狀態管理不受 TDD 分解機制影響

### 執行範例

```
情境：implementation.md 包含「建立用戶認證系統 - 使用 TDD 開發流程」

1. 檢測階段 → 識別 TDD 標註
2. 用戶標記 in_progress → 自動分解為：
   - 建立用戶認證系統 - 先跑測試 [pending]
   - 建立用戶認證系統 - 寫空介面 [pending]
   - 建立用戶認證系統 - 寫測試敘述 [pending]
   - 建立用戶認證系統 - 實作測試邏輯 [pending]
   - 建立用戶認證系統 - 跑測試（紅燈階段） [pending]
   - 建立用戶認證系統 - 實作實際程式碼 [pending]
   - 建立用戶認證系統 - 再次跑測試（綠燈階段） [pending]
3. 順序執行 → 第一個子任務自動變為 [in_progress]
4. 完成檢查 → 所有子任務 [completed] 後，母任務標記為 [x]
```

## AI 指示（Claude Code）

處理任務清單時，Claude Code 必須：

1. **首次載入任務：**
   - 讀取 `implementation.md` 檔案
   - 從「任務概要」區塊提取任務清單（僅包含任務標題和 checkbox）
   - 讀取 PRD 文件（從 `implementation.md` 中的「PRD 文件路徑」欄位取得路徑）
   - 讀取 `acceptance.feature` 檔案以了解驗收標準和大局觀點
   - 若 PRD 中引用了研究文件，一併讀取相關研究文件以獲得完整背景資訊
   - 使用 TodoWrite 工具將任務清單轉換為內部任務格式
   - 使用任務標題作為唯一識別方式（不使用編號）

2. **任務狀態管理：**
   - 使用 TodoWrite 工具管理任務狀態（pending、in_progress、completed）
   - 一次只能有一個任務處於 `in_progress` 狀態
   - 完成任務時立即更新為 `completed`

3. **執行任務時：**
   - **首先，讀取所有已完成任務的「實作備註」**：
     - 檢視 implementation.md 中所有已標記為 `[x]` 的任務的「實作備註」區塊
     - 特別關注：方向調整、技術障礙、關鍵決策、後續依賴等標籤
     - 目的：了解之前實作過程中遇到的問題和做出的調整，避免當前任務與前置脈絡不一致
     - 重點檢查：當前任務是否依賴前置任務、前置任務是否有方向調整影響當前任務
   - 從「任務細節」區塊找到對應的任務章節（標題與「任務概要」完全一致）
   - 參考「實作要點」進行實作
   - 檢查「相關檔案」了解需要修改的範圍
   - **完成實作後，必須執行「完成檢查」**：
     - 參考任務的「完成檢查」章節，執行所有檢查要點
     - 優先使用 MCP 工具進行檢查（如 supabase mcp、playwright mcp 等）
     - 其他檢查手段包括：執行測試指令、執行建置指令、手動驗證檔案內容等
     - 即使任務是撰寫文件，也應檢查文件是否達成預期目標
     - 所有檢查要點都通過後，才能進入下一步驟
   - 完成檢查通過後，填寫「實作備註」

4. **同步更新 implementation.md：**
   - 每當 TodoWrite 中的任務狀態改變時，立即更新 `implementation.md` 的「任務概要」區塊
   - 將完成的任務標記為 `[x]`
   - 使用 Edit 工具更新檔案

5. **新增任務：**
   - 當發現新任務時，同時更新：
     - TodoWrite 內部清單
     - `implementation.md` 的「任務概要」區塊（新增 checkbox 項目）
     - `implementation.md` 的「任務細節」區塊（新增完整任務章節）

6. **填寫實作備註：**
   - 執行任務過程中，遇到方向調整、技術障礙、關鍵決策、後續依賴時，**立即**記錄到「實作備註」區塊
   - 使用結構化標籤：`[方向調整]`、`[技術障礙]`、`[技術決策]`、`[後續依賴]`
   - 任務完成後，檢查實作備註是否完整，照預期完成的任務標註「照預期開發」
   - 參考「實作備註品質檢查清單」確保記錄品質

7. **TDD 任務處理：**
   - 檢測「使用 TDD 開發流程」標註，自動分解為 7 個子任務（詳見「TDD 任務自動分解機制」章節）
   - 按順序執行子任務，遵循 TDD 工作流程（詳見「TDD 開發流程」章節）

8. **驗收測試任務處理：**
   - 檢測任務標題或描述中包含以下關鍵詞的任務：
     - 「驗收測試」、「acceptance testing」、「驗收」、「validate implementation」
     - 「執行驗收測試」、「進行驗收」、「驗證實作」等相關詞彙
   - 當遇到驗收測試任務時，必須使用 Task tool 啟用 acceptance-tester agent
   - Task tool 的 prompt 參數必須包含以下三個文件的相對路徑（基於專案根目錄）：
     - `docs/specs/[專案目錄]/implementation.md`
     - `docs/specs/[專案目錄]/acceptance.feature`
     - `docs/specs/[專案目錄]/prd.md`
   - 範例 prompt 格式：
     ```
     請讀取 acceptance.feature 檔案、implementation.md 檔案和 prd.md 檔案，並執行所有 Gherkin 場景。

     檔案路徑：
     - implementation.md: docs/specs/2025-09-19-example-feature/implementation.md
     - acceptance.feature: docs/specs/2025-09-19-example-feature/acceptance.feature
     - prd.md: docs/specs/2025-09-19-example-feature/prd.md
     ```
   - 驗收測試任務應由 acceptance-tester agent 專門處理，不要在主對話中直接執行

9. **工作流程：**
   - 檢查下一個待處理任務，識別是否為 TDD 任務或驗收測試任務
   - 將任務標記為 `in_progress`（TDD 任務將自動分解，驗收測試任務啟用專門 agent）
   - 完成後標記為 `completed` 並同步更新 `implementation.md`
   - 等待用戶核准後再進行下一個任務

## 實作備註品質檢查清單

為確保實作備註的品質和一致性，請遵循以下檢查清單：

| 情況 | ✅ 良好範例 | ❌ 避免範例 |
|------|-----------|-----------|
| 按預期完成 | 「照預期開發」 | 列出所有實作細節（這些應該在任務敘述中） |
| 方向調整 | `[方向調整] 原用 X 但因 Y 不可行改用 Z，驗證後確認可行` | `改用了另一個方法` |
| 技術障礙 | `[技術障礙] X 限制導致 Y 問題，使用 Z 繞過，測試通過` | `遇到一些問題但解決了` |
| 關鍵決策 | `[技術決策] 比較 X 和 Y，選擇 Y 因 Z 考量，權衡是 W` | `決定用 Y` |
| 後續依賴 | `[後續依賴] 新增全域 config，後續任務需引入此檔案` | `做了一些修改` |

**記錄原則**：
- ✅ **需要記錄**：
  - 原任務敘述中提到的方法行不通，改用其他方法
  - 發現設計錯誤，需要修改先前的實作
  - 遇到預期外的技術限制（如 API 不支援、效能問題）
  - 與使用者討論超過 3 輪才確定的技術方案
  - 需要告知後續任務的重要資訊（如「必須先完成 X 才能做 Y」）

- ❌ **不需記錄**：
  - 按照任務敘述直接實作完成
  - 正常的除錯過程（如修正小的語法錯誤、typo）
  - 任務敘述中已經提到的實作細節
  - 常規的技術選擇（如選擇已知的資料結構、設計模式）

## TDD 開發流程

當執行 TDD 子任務時，必須嚴格遵循 Test-Driven Development (TDD) 方法論。每個子任務對應 TDD 流程中的特定階段，確保代碼品質並遵循 red-green-refactor 循環。

### 執行原則

- **嚴格順序**：按照子任務順序執行，不可跳過或重排
- **階段確認**：每個關鍵階段完成後等待開發者確認再進行下一步
- **專注當前**：專注於當前子任務，不要提前實現後續步驟的內容

### 修改現有程式碼的 TDD 流程

在處理現有程式碼修改任務時，第二步「確認介面修改需求」會根據修改類型採用不同策略：

#### 1. 新增 function 或 method
- **適用情境**：需要新增全新的 function 或 method
- **處理方式**：創建空介面實作，拋出「Not implemented」錯誤
- **範例**：新增 `calculateTax()` 方法到現有類別

#### 2. 純邏輯修正（介面不變）
- **適用情境**：修正現有邏輯錯誤，但 function 簽名保持不變
- **處理方式**：跳過空介面步驟，直接進行下一步（寫測試敘述）
- **範例**：修正計算錯誤、處理邊界條件、修復業務邏輯缺陷

#### 3. 介面參數變更
- **適用情境**：需要修改現有 function/method 的參數或返回值
- **處理方式**：先修改 function 簽名，保持實作邏輯為舊有或簡化版本
- **範例**：為 `login(username, password)` 新增第三個參數 `rememberMe`

### 關鍵規則

- **絕不** 撰寫期望「Not implemented」錯誤的測試邏輯

### 範例：正確 vs 錯誤的測試方法

#### 錯誤的測試方法 ❌
```typescript
// 空實現函數
export async function generateStaticParams(): Promise<{ slug: string }[]> {
  throw new Error('Not implemented')
}

// 錯誤的測試 - 直接期望 "Not implemented" 錯誤
it('returns all available note paths as static params', async () => {
  await expect(generateStaticParams()).rejects.toThrow('Not implemented')
})
```

#### 正確的測試方法 ✅
```typescript
// 空實現函數 (相同的起點)
export async function generateStaticParams(): Promise<{ slug: string }[]> {
  throw new Error('Not implemented')
}

// 正確的測試 - 測試預期的行為，不是現在的錯誤狀態
it('returns all available note paths as static params', async () => {
  // Mock 檔案系統或數據源
  const mockNotes = ['note1.md', 'note2.md', 'note3.md']
  jest.spyOn(fs, 'readdir').mockResolvedValue(mockNotes)

  const result = await generateStaticParams()
  
  expect(result).toEqual([
    { slug: 'note1' },
    { slug: 'note2' },
    { slug: 'note3' }
  ])
  expect(result).toHaveLength(3)
})
```

**關鍵差異：**
- 錯誤方法測試目前的實現狀態（拋出錯誤）
- 正確方法測試我們想要的最終行為（返回 note paths）
- 正確方法在紅燈階段會失敗，因為函數還沒實現預期邏輯
- 正確方法指導我們需要實現什麼功能來讓測試通過
- **絕不** 撰寫沒有真實實現就保證通過的測試
- **絕不** 在撰寫測試之前實現實際邏輯
- 初期專注於主流程和主要錯誤情況，而非全面覆蓋
- 在實現測試邏輯之前總是確認測試描述
- 實現使用 TypeScript，代碼/註釋使用英文
- 討論使用繁體中文溝通

### 品質保證

- 確保紅燈階段確實因正確原因失敗
- 保持測試邏輯合理且有意義
- 如果技術問題阻止測試通過，與開發者討論解決方案，而不是人為修改測試使其通過
- 在測試描述階段和測試實現階段之間保持清晰分離

### 輸出格式

清楚指示當前處於哪個階段和正在做什麼。在主要階段之間移動前詢問確認（特別是在實現測試邏輯之前和實現實際代碼之前）。


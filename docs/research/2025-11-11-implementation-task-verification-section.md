# 研究報告：為 Implementation 任務新增「驗收方式」章節

## 執行摘要

本研究探討如何在 `/create-impl-plan` 生成的 `implementation.md` 任務細節中新增「驗收方式」章節，以提供任務層級的快速驗證指引。這個新章節與端到端的「執行驗收測試」任務有明確的區分：

- **驗收方式章節**：針對單一任務完成後的快速驗證方法（1-5 條簡要說明）
- **執行驗收測試任務**：完成整個功能後的端到端系統性驗收（Gherkin 格式的完整場景）

經過深入分析後，建議採用以下設計方案：

1. **位置設計**：在「相關檔案」和「實作備註」之間插入「驗收方式」章節
2. **內容原則**：簡潔實用的驗證指引（1-5 條），涵蓋測試、工具驗證（MCP）、指令驗證等方式
3. **適用範圍**：除了「執行驗收測試」和「更新專案文件」兩個固定任務外，所有任務都應包含此章節
4. **TDD 特殊處理**：標註「使用 TDD 開發流程」的任務統一使用「執行測試確認通過」作為驗收方式

## 背景與脈絡

在 claude-code-config 的三步驟開發流程中，第二步「實作規劃」（`/create-impl-plan`）會生成包含 5-7 個任務的 `implementation.md` 檔案。目前每個任務包含三個固定區塊：

1. **實作要點**：具體的實作步驟（條列式）
2. **相關檔案**：該任務需要修改的檔案清單
3. **實作備註**：執行時填寫的上下文記錄

在任務清單的最後，固定包含兩個必要任務：

- **執行驗收測試**：使用 acceptance-tester agent 執行 `acceptance.feature` 中的 Gherkin 場景，進行完整的端到端驗收
- **更新專案文件**：更新 README.md、CLAUDE.md 等專案層級文件

然而，目前的架構缺少了一個重要環節：**如何快速驗證單一任務是否已經正確完成**。開發者完成一個任務後，需要有明確的指引來確認該任務的產出符合預期，而不需要等到最後才進行完整的端到端驗收測試。

## 研究問題與發現過程

### 初始問題定義

使用者提出的核心需求是：在完成單一任務時，需要有清楚的方式來確認任務已經完成。這個驗收方式與最後的端到端驗收測試不同，它是針對任務層級的快速驗證。

### 需求釐清過程

經過互動式問答，我們釐清了以下關鍵需求：

1. **章節位置**：插入在「相關檔案」和「實作備註」之間
2. **內容形式**：簡要的條列式說明（1-5 條），例如：
   - 「執行 `npm test` 確認新增的單元測試通過」
   - 「使用 `curl` 測試 API 端點回傳 200 狀態碼」
   - 「用 supabase mcp 確認表格的欄位確實有新增」
   - 「用 playwright mcp 打開修改過的元件所在頁面，確認修改符合預期」
3. **排除範圍**：「執行驗收測試」和「更新專案文件」兩個固定任務不需要此章節
4. **TDD 任務處理**：標註「使用 TDD 開發流程」的任務驗收方式固定為「執行測試確認通過」
5. **生成方式**：由 AI 根據任務內容自動推斷生成

### 問題分析

深入分析現有架構後，我們發現這個需求實際上填補了兩個驗證層級之間的空白：

- **微觀層級（新增）**：任務完成後的即時驗證
- **宏觀層級（既有）**：整個功能完成後的端到端驗收測試

這個設計符合軟體開發的最佳實踐：在開發過程中頻繁驗證（fast feedback），在功能完成後進行全面驗證（comprehensive testing）。

## 技術分析：深入理解問題

### 程式碼庫現況探索

經過分析，我們發現 `implementation.md` 的任務結構具有以下特點：

**雙層結構設計**：
- 「任務概要」：簡潔的 checkbox 列表，用於快速瀏覽和 TodoWrite 同步
- 「任務細節」：每個任務的完整章節，包含實作要點、相關檔案、實作備註

**固定的任務細節結構**（目前）：
```markdown
### 任務標題

**實作要點**
- 實作步驟 1
- 實作步驟 2

**相關檔案**
- `path/to/file.ts` - 說明

**實作備註**
<!-- 執行過程中填寫 -->
```

**特殊任務類型**：
1. **TDD 任務**：標題包含「使用 TDD 開發流程」，在執行時會自動展開為 7 個子任務
2. **驗收測試任務**：固定標題「執行驗收測試」，會啟用 acceptance-tester agent
3. **文件更新任務**：固定標題「更新專案文件」，負責更新專案層級文件

### 驗證方式的多樣性分析

透過分析現有的 implementation.md 範例和 acceptance.feature 檔案，我們識別出以下幾種常見的驗證方式：

**1. 單元測試驗證**（最常見）
- 適用於：實作新功能、修改邏輯
- 範例：「執行 `npm test` 確認單元測試通過」
- 特點：適合 TDD 任務的標準驗收方式

**2. 指令驗證**
- 適用於：CLI 工具、腳本功能
- 範例：「執行 `npm run install-config` 確認安裝成功且無錯誤」
- 特點：可以直接在終端機執行，驗證結果明確

**3. API 端點驗證**
- 適用於：後端 API 開發
- 範例：「使用 `curl` 測試 POST /api/users 端點回傳 201 狀態碼」
- 特點：可以使用 curl、httpie 等工具快速驗證

**4. 資料庫驗證（MCP: Supabase）**
- 適用於：資料庫 schema 變更、資料操作
- 範例：
  - 「用 supabase mcp 確認 users 表格新增了 email_verified 欄位」
  - 「用 supabase mcp 插入測試資料，確認 unique constraint 正常運作」
- 特點：需要使用 MCP 工具進行驗證

**5. 前端 UI 驗證（MCP: Playwright）**
- 適用於：UI 元件修改、頁面調整
- 範例：「用 playwright mcp 打開 /settings 頁面，確認暗色模式切換按鈕顯示正確」
- 特點：需要使用瀏覽器自動化工具

**6. 檔案結構驗證**
- 適用於：檔案組織、重構任務
- 範例：「確認 `src/components/` 目錄下所有檔案都已移動到 `src/ui/` 目錄」
- 特點：可以使用 `ls`、`tree` 等指令或直接檢視檔案系統

**7. 建置驗證**
- 適用於：影響建置流程的變更
- 範例：「執行 `npm run build` 確認無 TypeScript 錯誤且建置成功」
- 特點：確保變更不會破壞專案建置

### 與端到端驗收測試的區分

**驗收方式章節（任務層級）**：
- **時機**：完成單一任務後立即驗證
- **目的**：快速確認該任務的產出符合預期
- **範圍**：聚焦於當前任務相關的功能點
- **深度**：簡要驗證（1-5 條）
- **執行者**：開發者或 AI 助手在主對話中執行
- **範例**：「執行單元測試」、「用 curl 測試 API」、「檢查檔案是否建立」

**執行驗收測試任務（功能層級）**：
- **時機**：所有功能任務完成後才執行
- **目的**：系統化驗證整個功能是否符合 PRD 需求
- **範圍**：涵蓋完整的使用者場景和業務流程
- **深度**：詳細的 Gherkin 場景（Given-When-Then）
- **執行者**：專門的 acceptance-tester agent
- **範例**：完整的使用者註冊流程、購物車到結帳的完整流程

這兩個層級的驗證互補，形成完整的品質保證機制。

## 解決方案探索與評估

### 方案一：在所有任務中新增「驗收方式」章節

**核心設計**：
- 在「相關檔案」和「實作備註」之間插入新章節
- 除了「執行驗收測試」和「更新專案文件」外，所有任務都包含此章節
- TDD 任務使用固定的驗收方式「執行測試確認通過」
- 其他任務由 AI 根據任務內容自動生成驗收方式

**優點**：
- 提供清晰的任務完成標準
- 促進快速反饋循環（fast feedback）
- 降低開發者的認知負擔（不需要自己思考如何驗證）
- 與現有架構無縫整合

**缺點**：
- 增加 AI 生成的複雜度（需要推斷合適的驗收方式）
- 可能產生不適切或過於簡化的驗收方式
- 增加文件長度，但影響輕微

**實作複雜度**：中等
- 需要修改 `create-impl-plan.md` 的輸出格式
- 需要設計 AI 指示來生成合適的驗收方式
- 需要處理特殊任務類型的例外情況

**維護影響**：低
- 新增章節不影響現有邏輯
- 與 TodoWrite、Git 工作流程無衝突
- 未來可以持續優化 AI 生成邏輯

**風險等級**：低
- 純新增功能，不修改現有行為
- 如果生成不適切，開發者可以忽略或手動調整
- 可以逐步改進 AI 生成品質

### 方案二：僅在特定任務類型中新增「驗收方式」

**核心設計**：
- 只在容易驗證的任務中新增此章節（如：API 開發、資料庫變更）
- 複雜任務或驗證困難的任務不新增

**優點**：
- 降低 AI 生成錯誤的風險
- 避免產生無用的驗收方式

**缺點**：
- 一致性較差，部分任務有、部分沒有
- AI 需要額外判斷任務類型
- 增加實作複雜度

**評估結果**：不建議採用
- 與使用者需求不符（希望除了兩個固定任務外都有）
- 破壞文件結構的一致性

### 方案三：使用註解或可選欄位

**核心設計**：
- 將驗收方式設計為可選欄位
- 如果 AI 無法生成合適的驗收方式，留空或提供預設提示

**優點**：
- 提供彈性
- 降低 AI 生成壓力

**缺點**：
- 不符合使用者期望（希望所有適用任務都有此章節）
- 空欄位可能造成困惑

**評估結果**：不建議採用

## 建議與決策指引

基於以上分析，建議採用**方案一：在所有任務中新增「驗收方式」章節**，並搭配以下實施策略：

### 章節設計規範

**位置**：在「相關檔案」後、「實作備註」前插入

**標題**：`**驗收方式**`（使用 Markdown 加粗格式，與其他子區塊一致）

**內容原則**：
1. **簡潔性**：1-5 條驗收要點，通常 1-2 條最理想
2. **可執行性**：提供具體可執行的驗證方法
3. **相關性**：聚焦於該任務的產出
4. **多樣性**：根據任務特性選擇適當的驗證方式

**格式範例**：

```markdown
### 實作用戶註冊 API - 使用 TDD 開發流程

**實作要點**
- 建立 POST /api/users 端點
- 實作 email 和密碼驗證邏輯
- 使用 TDD 開發流程：先寫測試，確保紅燈，再實作功能至綠燈

**相關檔案**
- `src/api/users.ts` - 用戶註冊 API 實作
- `src/api/users.test.ts` - 單元測試

**驗收方式**
- 執行測試確認通過

**實作備註**
<!-- 執行過程中填寫 -->
```

```markdown
### 建立資料庫 users 表格

**實作要點**
- 建立 users 表格包含 id, email, password_hash, created_at 欄位
- 設定 email 欄位為 unique
- 建立適當的索引

**相關檔案**
- `supabase/migrations/20250111_create_users_table.sql` - 資料庫遷移檔案

**驗收方式**
- 使用 supabase mcp 確認 users 表格存在且欄位正確
- 插入兩筆相同 email 的測試資料，確認第二筆因 unique constraint 而失敗

**實作備註**
<!-- 執行過程中填寫 -->
```

```markdown
### 實作暗色模式切換元件

**實作要點**
- 建立 ThemeToggle 元件包含切換按鈕
- 整合 context 或 state management 處理主題狀態
- 確保切換後樣式正確套用

**相關檔案**
- `src/components/ThemeToggle.tsx` - 主題切換元件
- `src/contexts/ThemeContext.tsx` - 主題狀態管理

**驗收方式**
- 使用 playwright mcp 打開包含 ThemeToggle 的頁面，點擊切換按鈕，確認頁面背景色和文字色正確變更

**實作備註**
<!-- 執行過程中填寫 -->
```

### AI 生成邏輯指引

在 `create-impl-plan.md` 中新增指導，說明如何為不同任務類型生成驗收方式：

**1. TDD 任務（標註「使用 TDD 開發流程」）**
- 固定使用：「執行測試確認通過」
- 不需要額外推斷

**2. 實作新功能或修改邏輯的任務**
- 優先考慮單元測試
- 範例：「執行 `npm test` 確認新增/修改的測試通過」

**3. API 開發任務**
- 建議使用 curl 或 API 測試工具
- 範例：「使用 `curl -X POST http://localhost:3000/api/users` 測試端點回應正確」

**4. 資料庫相關任務**
- 建議使用 supabase mcp（如果專案使用 Supabase）
- 範例：「使用 supabase mcp 查詢表格確認 schema 變更正確」

**5. 前端 UI 任務**
- 建議使用 playwright mcp（如果可用）
- 範例：「使用 playwright mcp 開啟頁面，確認元件顯示符合預期」

**6. CLI 工具或腳本任務**
- 建議執行指令驗證
- 範例：「執行 `node scripts/migrate.js` 確認腳本正常運作無錯誤」

**7. 檔案結構重構任務**
- 建議檢查檔案系統
- 範例：「確認所有檔案已移動到新位置且舊位置已清空」

**8. 建置相關任務**
- 建議執行建置指令
- 範例：「執行 `npm run build` 確認建置成功無錯誤」

**9. 環境設定任務**
- 建議驗證環境變數或設定檔
- 範例：「確認 `.env` 檔案包含所有必要的環境變數」

**10. 複雜任務（難以單一驗證）**
- 提供多個驗收要點（最多 5 條）
- 涵蓋主要產出的驗證方式

### 排除規則

以下任務類型**不應**包含「驗收方式」章節：

1. **執行驗收測試**：任務本身就是驗收測試
2. **更新專案文件**：文件更新的驗證較為主觀，且通常透過 PR review 進行

### 實施順序

1. **修改 `create-impl-plan.md` 輸出格式**（第 100-216 行附近）
   - 在任務細節結構中新增「驗收方式」章節
   - 更新範例展示新的章節位置

2. **新增 AI 生成指示**（第 72-98 行的流程說明中）
   - 在流程第 4 步「生成任務與任務說明」中加入驗收方式生成邏輯
   - 提供針對不同任務類型的生成指引

3. **更新任務格式說明**（第 261-325 行）
   - 在「任務細節結構」中說明新的「驗收方式」子區塊
   - 提供多種任務類型的範例

4. **驗證與測試**
   - 使用真實的 PRD 測試新格式的生成
   - 確認生成的驗收方式合理且可執行

## 下一步行動計畫

### 立即行動

1. **撰寫 PRD**：基於此研究文件撰寫完整的 PRD，明確定義需求和驗收標準
2. **修改 `create-impl-plan.md`**：實施上述建議的設計方案

### 中期目標

1. **收集使用者反饋**：觀察新章節的實際使用效果，持續優化 AI 生成邏輯
2. **建立驗收方式模板庫**：累積常見任務類型的驗收方式範例

### PRD 需求

建議為此功能撰寫 PRD，涵蓋以下內容：

- **功能概述**：為任務新增驗收方式章節
- **用戶故事**：開發者完成任務後，需要清楚知道如何驗證任務完成
- **詳細需求**：
  - 章節位置和格式
  - AI 生成邏輯
  - 排除規則
  - 不同任務類型的處理方式
- **驗收標準**：
  - 生成的 implementation.md 包含驗收方式章節
  - TDD 任務使用固定驗收方式
  - 排除任務不包含此章節
  - 驗收方式簡潔實用（1-5 條）

## 參考資料

### 技術文件

- [create-impl-plan.md](../../../commands/create-impl-plan.md) - 實作計畫生成指令
- [process-task-list.md](../../../commands/process-task-list.md) - 任務執行指令
- [acceptance-tester.md](../../../agents/acceptance-tester.md) - 驗收測試 agent

### 實作範例

- [2025-09-19-implementation-context-transfer/implementation.md](../../docs/specs/2025-09-19-implementation-context-transfer/implementation.md) - 高品質實作計畫範例
- [2025-10-30-workflow-context-awareness/implementation.md](../../docs/specs/2025-10-30-workflow-context-awareness/implementation.md) - 完整任務結構範例

### 延伸閱讀

- Test-Driven Development (TDD) 最佳實踐
- Fast Feedback Loops in Software Development
- Acceptance Testing vs Unit Testing
